<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arduino Serial Redirector</title>
    <style>
        body {
            font-family: sans-serif;
            text-align: center;
            padding-top: 50px;
        }

        h1 {
            font-size: 10rem;
        }

        #status {
            margin: 20px;
            padding: 10px;
            border: 1px solid #ccc;
        }

        button {
            padding: 10px 20px;
            font-size: 1.2rem;
            cursor: pointer;
        }

        .connected {
            color: green;
        }

        .disconnected {
            color: red;
        }
    </style>
</head>

<body>
    <h1>è¿‘ã¥ã„ã¦ãã ã•ã„</h1>
    <p>ã€ã‚»ãƒƒãƒ†ã‚£ãƒ³ã‚°æ–¹æ³•ã€‘<br>Arduinoã‚’æ¥ç¶šã—ã¦ã€ä¸‹ã®ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚</p>

    <button id="connectBtn">Arduinoã«æ¥ç¶šã™ã‚‹</button>
    <div id="status" class="disconnected">æ¥ç¶šçŠ¶æ…‹: æœªæ¥ç¶š</div>

    <script>
        const connectBtn = document.getElementById('connectBtn');
        const statusDiv = document.getElementById('status');

        // é·ç§»å…ˆã®ãƒ™ãƒ¼ã‚¹URLï¼ˆGitHub Pagesä¸Šã®åˆ¥ãƒšãƒ¼ã‚¸ãªã©ï¼‰
        const DESTINATION_URL = "result.html";

        let currentPort = null;
        let isProcessing = false; // é‡è¤‡å‡¦ç†ã‚’é˜²ããƒ•ãƒ©ã‚°
        let lastProcessedId = null; // æœ€å¾Œã«å‡¦ç†ã—ãŸID
        let lastProcessedTime = 0; // æœ€å¾Œã«å‡¦ç†ã—ãŸæ™‚åˆ»

        // ã‚·ãƒªã‚¢ãƒ«ãƒãƒ¼ãƒˆã«æ¥ç¶šã—ã¦å—ä¿¡ã‚’é–‹å§‹ã™ã‚‹é–¢æ•°
        async function connectAndListen(port, isReconnection = false) {
            try {
                console.log("=== æ¥ç¶šé–‹å§‹ ===");
                console.log("å†æ¥ç¶š:", isReconnection);
                console.log("ãƒãƒ¼ãƒˆèª­ã¿å–ã‚Šå¯èƒ½:", port.readable !== null);

                if (!port.readable) {
                    console.log("ãƒãƒ¼ãƒˆã‚’é–‹ãã¾ã™...");
                    await port.open({ baudRate: 9600 }); // Arduinoå´ã®Serial.beginã¨åˆã‚ã›ã‚‹
                    console.log("ãƒãƒ¼ãƒˆé–‹ã„ãŸï¼");
                } else {
                    console.log("ãƒãƒ¼ãƒˆã¯æ—¢ã«é–‹ã„ã¦ã„ã¾ã™");
                }

                currentPort = port;
                statusDiv.innerText = "æ¥ç¶šçŠ¶æ…‹: æ¥ç¶šä¸­ï¼ˆãƒ•ãƒ©ã‚°å¾…æ©Ÿä¸­...ï¼‰";
                statusDiv.className = "connected";
                connectBtn.style.display = "none";

                const decoder = new TextDecoderStream();
                port.readable.pipeTo(decoder.writable);
                const reader = decoder.readable.getReader();
                console.log("ãƒªãƒ¼ãƒ€ãƒ¼æº–å‚™å®Œäº†ï¼ãƒ‡ãƒ¼ã‚¿å¾…æ©Ÿä¸­...");

                // å—ä¿¡ãƒ«ãƒ¼ãƒ—
                console.log("ğŸ“¡ å—ä¿¡ãƒ«ãƒ¼ãƒ—é–‹å§‹");
                while (true) {
                    const { value, done } = await reader.read();
                    console.log("èª­ã¿å–ã‚Šçµæœ - done:", done, "value:", value);
                    if (done) {
                        console.log("âŒ ã‚¹ãƒˆãƒªãƒ¼ãƒ çµ‚äº†");
                        break;
                    }
                    if (value) {
                        // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šå—ä¿¡ãƒ‡ãƒ¼ã‚¿ã®è©³ç´°ã‚’è¡¨ç¤º
                        console.log("âœ‰ï¸ Receive:", value);
                        console.log("  Length:", value.length);
                        console.log("  Trimmed:", value.trim());
                        console.log("  Char codes:", Array.from(value).map(c => c.charCodeAt(0)));

                        // ã™ã§ã«å‡¦ç†ä¸­ã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
                        if (isProcessing) {
                            console.log("å‡¦ç†ä¸­ã®ãŸã‚ã‚¹ã‚­ãƒƒãƒ—");
                            continue;
                        }

                        // 1, 2, 3 ã®ã„ãšã‚Œã‹ã‚’å«ã‚€ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆã‚ˆã‚ŠæŸ”è»Ÿã«ï¼‰
                        const trimmed = value.trim();
                        const match = trimmed.match(/([1-3])/);
                        if (match) {
                            const id = match[1];
                            const currentTime = Date.now();
                            console.log("âœ“ IDæ¤œå‡º:", id);

                            // åŒã˜IDã‚’1ç§’ä»¥å†…ã«å‡¦ç†ã—ãªã„ã‚ˆã†ã«ã™ã‚‹ï¼ˆãƒ‡ãƒã‚¦ãƒ³ã‚¹ï¼‰
                            if (id === lastProcessedId && (currentTime - lastProcessedTime) < 1000) {
                                console.log("åŒã˜IDã®ãŸã‚ç„¡è¦–:", id);
                                continue;
                            }

                            // å‡¦ç†é–‹å§‹
                            isProcessing = true;
                            lastProcessedId = id;
                            lastProcessedTime = currentTime;

                            console.log("IDæ¤œå‡º:", id, "â†’ ãƒšãƒ¼ã‚¸é·ç§»ã—ã¾ã™");

                            // æ¥ç¶šã‚’ç¶­æŒã—ãŸã¾ã¾é·ç§»
                            reader.releaseLock();
                            // ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ã¤ã‘ã¦é·ç§»
                            window.location.href = `${DESTINATION_URL}?id=${id}`;
                            break;
                        }
                    }
                }
            } catch (error) {
                console.error('Error:', error);
                statusDiv.innerText = "ã‚¨ãƒ©ãƒ¼: " + error.message;
                statusDiv.className = "disconnected";
                connectBtn.style.display = "block";
                isProcessing = false;
            }
        }

        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«ä»¥å‰æ¥ç¶šã—ãŸãƒãƒ¼ãƒˆãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        window.addEventListener('load', async () => {
            try {
                const ports = await navigator.serial.getPorts();
                if (ports.length > 0) {
                    // ä»¥å‰æ¥ç¶šã—ãŸãƒãƒ¼ãƒˆãŒã‚ã‚Œã°è‡ªå‹•çš„ã«å†æ¥ç¶š
                    console.log("ä»¥å‰æ¥ç¶šã—ãŸãƒãƒ¼ãƒˆã‚’æ¤œå‡ºã—ã¾ã—ãŸã€‚è‡ªå‹•å†æ¥ç¶šã—ã¾ã™...");
                    await connectAndListen(ports[0], true); // å†æ¥ç¶šãƒ•ãƒ©ã‚°ã‚’true
                }
            } catch (error) {
                console.error('è‡ªå‹•å†æ¥ç¶šã‚¨ãƒ©ãƒ¼:', error);
            }
        });

        // æ‰‹å‹•æ¥ç¶šãƒœã‚¿ãƒ³
        connectBtn.addEventListener('click', async () => {
            try {
                // ã‚·ãƒªã‚¢ãƒ«ãƒãƒ¼ãƒˆã®è¦æ±‚
                const port = await navigator.serial.requestPort();
                await connectAndListen(port, false); // åˆå›æ¥ç¶š
            } catch (error) {
                console.error('Error:', error);
                statusDiv.innerText = "ã‚¨ãƒ©ãƒ¼: " + error.message;
                statusDiv.className = "disconnected";
            }
        });
    </script>
</body>

</html>